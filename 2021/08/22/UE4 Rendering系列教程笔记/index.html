<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="教程原文链接：https:&#x2F;&#x2F;medium.com&#x2F;@lordned&#x2F;unreal-engine-4-rendering-overview-part-1-c47f2da65346">
<meta property="og:type" content="article">
<meta property="og:title" content="UE4 Rendering系列教程笔记">
<meta property="og:url" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="tohiro&#39;s Blog">
<meta property="og:description" content="教程原文链接：https:&#x2F;&#x2F;medium.com&#x2F;@lordned&#x2F;unreal-engine-4-rendering-overview-part-1-c47f2da65346">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image.jpg">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image.png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[1].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[2].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[3].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[4].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[5].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[6].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[7].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[8].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[9].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[10].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[11].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[12].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[13].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[14].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[15].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[16].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[17].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[18].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[19].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[20].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[21].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[22].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[23].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[24].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[25].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[26].png">
<meta property="og:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image%20[27].png">
<meta property="article:published_time" content="2021-08-22T06:43:37.877Z">
<meta property="article:modified_time" content="2021-08-20T06:50:02.000Z">
<meta property="article:author" content="Chen Yuren">
<meta property="article:tag" content="UE4">
<meta property="article:tag" content="ShadingModel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image.jpg">


<link rel="canonical" href="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/","path":"2021/08/22/UE4 Rendering系列教程笔记/","title":"UE4 Rendering系列教程笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>UE4 Rendering系列教程笔记 | tohiro's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">tohiro's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part1-Introduction"><span class="nav-number">1.</span> <span class="nav-text">Part1 Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Engine-Setup"><span class="nav-number">1.1.</span> <span class="nav-text">Engine Setup</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HLSL-Tools-for-Visual-Studio"><span class="nav-number">1.1.1.</span> <span class="nav-text">HLSL Tools for Visual Studio</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RenderDoc"><span class="nav-number">1.1.2.</span> <span class="nav-text">RenderDoc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Modify-ConsoleVariables-ini"><span class="nav-number">1.1.3.</span> <span class="nav-text">Modify ConsoleVariables.ini</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Modify-BaseEngine-ini"><span class="nav-number">1.1.4.</span> <span class="nav-text">Modify BaseEngine.ini</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part2-Shader-and-Vertex-Data"><span class="nav-number">2.</span> <span class="nav-text">Part2 Shader and Vertex Data</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vertex-Factory"><span class="nav-number">2.0.1.</span> <span class="nav-text">Vertex Factory</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shaders"><span class="nav-number">2.1.</span> <span class="nav-text">Shaders</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Caching-and-Compilation-Environments"><span class="nav-number">2.2.</span> <span class="nav-text">Caching and Compilation Environments</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FVertexFactory"><span class="nav-number">2.2.1.</span> <span class="nav-text">FVertexFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FPrimitiveSceneProxy"><span class="nav-number">2.2.2.</span> <span class="nav-text">FPrimitiveSceneProxy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binding-C-to-HLSL"><span class="nav-number">2.3.</span> <span class="nav-text">Binding C++ to HLSL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part3-Drawing-Policies"><span class="nav-number">3.</span> <span class="nav-text">Part3 Drawing Policies</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Drawing-Policies"><span class="nav-number">3.1.</span> <span class="nav-text">Drawing Policies</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FDepthDrawingPolicy"><span class="nav-number">3.1.1.</span> <span class="nav-text">FDepthDrawingPolicy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FBasePassDrawingPolicy"><span class="nav-number">3.1.2.</span> <span class="nav-text">FBasePassDrawingPolicy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Drawing-Policy-Factory"><span class="nav-number">3.2.</span> <span class="nav-text">Drawing Policy Factory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FdepthDrawingPolicyFactory"><span class="nav-number">3.2.1.</span> <span class="nav-text">FdepthDrawingPolicyFactory</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part4-The-Deferred-Shading-Pipeline"><span class="nav-number">4.</span> <span class="nav-text">Part4 The Deferred Shading Pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vertex-Factories"><span class="nav-number">4.1.</span> <span class="nav-text">Vertex Factories</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Changing-Input-Data"><span class="nav-number">4.1.1.</span> <span class="nav-text">Changing Input Data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Changing-Output-Data"><span class="nav-number">4.1.2.</span> <span class="nav-text">Changing Output Data</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Base-Pass-Pixel-Shader"><span class="nav-number">4.2.</span> <span class="nav-text">Base Pass Pixel Shader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Material-Graph-to-HLSL"><span class="nav-number">4.2.1.</span> <span class="nav-text">Material Graph to HLSL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-%E2%80%9CPrimitive%E2%80%9D-Variable"><span class="nav-number">4.2.2.</span> <span class="nav-text">The “Primitive” Variable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Creating-the-GBuffer"><span class="nav-number">4.2.3.</span> <span class="nav-text">Creating the GBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Setting-the-GBuffer-Shading-Model"><span class="nav-number">4.2.4.</span> <span class="nav-text">Setting the GBuffer Shading Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-the-Data"><span class="nav-number">4.2.5.</span> <span class="nav-text">Using the Data</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deferred-Light-Pixel-Shader"><span class="nav-number">4.3.</span> <span class="nav-text">Deferred Light Pixel Shader</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part6-Adding-a-New-Shading-Model"><span class="nav-number">5.</span> <span class="nav-text">Part6 Adding a New Shading Model</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chen Yuren</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chen Yuren">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tohiro's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          UE4 Rendering系列教程笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-22 14:43:37" itemprop="dateCreated datePublished" datetime="2021-08-22T14:43:37+08:00">2021-08-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-20 14:50:02" itemprop="dateModified" datetime="2021-08-20T14:50:02+08:00">2021-08-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/UE4/" itemprop="url" rel="index"><span itemprop="name">UE4</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>教程原文链接：<a target="_blank" rel="noopener" href="https://medium.com/@lordned/unreal-engine-4-rendering-overview-part-1-c47f2da65346">https://medium.com/@lordned/unreal-engine-4-rendering-overview-part-1-c47f2da65346</a></p>
<span id="more"></span>

<h2 id="Part1-Introduction"><a href="#Part1-Introduction" class="headerlink" title="Part1 Introduction"></a>Part1 Introduction</h2><p>​        这个部分介绍了这个教程的一些基本内容，并且推荐了一些常用的插件以及配置。</p>
<h3 id="Engine-Setup"><a href="#Engine-Setup" class="headerlink" title="Engine Setup"></a>Engine Setup</h3><p>​        下载源码编译，设置模式为“Debug Editor”而非“develop editor”。（两者差别日后查阅更多资料之后补充）</p>
<h4 id="HLSL-Tools-for-Visual-Studio"><a href="#HLSL-Tools-for-Visual-Studio" class="headerlink" title="HLSL Tools for Visual Studio"></a>HLSL Tools for Visual Studio</h4><p>​        “工具 -&gt; 扩展和更新… -&gt; 联机” 搜索“HLSL Tools for Visual Studio”，下载并根据提示安装。在”工具 -&gt; 选项 -&gt; 文本编辑器 -&gt; 文件扩展名”中做如下编辑：</p>
<p><img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image.jpg" alt="Image"></p>
<h4 id="RenderDoc"><a href="#RenderDoc" class="headerlink" title="RenderDoc"></a>RenderDoc</h4><p>​        截帧工具。在UE4里面使用的相关教程：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013412391/article/details/108504585">https://blog.csdn.net/u013412391/article/details/108504585</a></p>
<p>​        github：<a target="_blank" rel="noopener" href="https://github.com/baldurk/renderdoc">https://github.com/baldurk/renderdoc</a></p>
<h4 id="Modify-ConsoleVariables-ini"><a href="#Modify-ConsoleVariables-ini" class="headerlink" title="Modify ConsoleVariables.ini"></a>Modify ConsoleVariables.ini</h4><p>​        “\Engine\Config”路径下。（以下变量貌似默认情况下都是设置好的）</p>
<p>​        主要关注参数：</p>
<p>​        <strong>r.ShaderDevelopmentMode = 1</strong>：当材质缺省导致编译失败时可以重新编译。</p>
<p>​        <strong>r.Shaders.Optimize = 0 &amp; r.Shaders.KeepDebugInfo=1</strong> ：让Unreal使用低优化编译器，保留调试信息。这样可以降低编译时间，并且保存debug信息，这样可以更好地在RenderDoc里面debug。</p>
<p>​        <strong>r.DumpShaderDebugInfo = 1 &amp; r.DumpShaderDebugShortNames = 1</strong> ：在某些情况下很有用。DumpShaderDebugInfo会将生成HLSL写入硬盘（占用两个G的内存），但可以帮助RenderDoc调试；第二个变量可以缩短变量名称，以符合OS的最大路径长度限制。</p>
<h4 id="Modify-BaseEngine-ini"><a href="#Modify-BaseEngine-ini" class="headerlink" title="Modify BaseEngine.ini"></a>Modify BaseEngine.ini</h4><p><strong>[DevOptions.Shaders]</strong></p>
<p>​    <strong>bAllowCompilingThroughWorker = True &amp; bAllowAsynchronousShaderCompiling = True</strong>, 这两个变量可以让UE4进行多线程编译所有需要的shader。如果你需要只调试某个C++ shader管线，把这两个变量设置为False会非常有用，但这会使shader的编译时间变长。</p>
<h2 id="Part2-Shader-and-Vertex-Data"><a href="#Part2-Shader-and-Vertex-Data" class="headerlink" title="Part2 Shader and Vertex Data"></a>Part2 Shader and Vertex Data</h2><h4 id="Vertex-Factory"><a href="#Vertex-Factory" class="headerlink" title="Vertex Factory"></a>Vertex Factory</h4><p>Unreal使用Vertex Factory来控制数据从Vertex Shader上传到GPU中。</p>
<h3 id="Shaders"><a href="#Shaders" class="headerlink" title="Shaders"></a>Shaders</h3><ul>
<li>所有Shader的基类：FShader — FGlobalShader（<strong>只有一个实例存在</strong>） &amp; FMaterialShader（与材质绑定）。<ul>
<li>FShader与FShaderResource成对出现，FShaderResource追踪一个Shader在GPU上的相关资源。如果FShader编译的结果与已经存在的结果一致，那么它们就可以共享一个FShaderResource。</li>
<li>FGlobalShader////</li>
<li>FMaterialShader：使用SetParamaters函数来用C++代码修改HLSL中的参数。参数的绑定是通过FShaderParameter / FShaderResourceParameter类在shader的构造函数中完成。</li>
<li>FMeshMaterialShader：可以将Mesh的顶点数据引入到Shader端。（from <a target="_blank" rel="noopener" href="https://blog.ch-wind.com/ue4-rendering-code-view-01/">UE4渲染代码逻辑总结（上） | 风蚀之月 (ch-wind.com)</a>）</li>
</ul>
</li>
</ul>
<h3 id="Caching-and-Compilation-Environments"><a href="#Caching-and-Compilation-Environments" class="headerlink" title="Caching and Compilation Environments"></a>Caching and Compilation Environments</h3><ul>
<li><code>ShouldCache</code>函数：如果Shader、Material、Vertex Factory全都同意某个特定组合被缓存，那么FShader才会创建这个特定组合；相反，只要有其中之一不同意，那么这个组合就会被跳过。<ul>
<li>Unreal会自动为一个Shader编译大量可能的组合，这个有它的好处在，但同时会生成许多无用的Shader。</li>
<li><code>ShaderCache</code>函数是一个可以在FShader、FMaterial、FVertexFactory中实现的静态函数。（按官方文档的示例说明，就是返回值是true时编译<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image.png" alt="Image">当前shader，否则就不编译。)</li>
</ul>
</li>
</ul>
<h4 id="FVertexFactory"><a href="#FVertexFactory" class="headerlink" title="FVertexFactory"></a>FVertexFactory</h4><ul>
<li>包含顶点数据，并且被链接到顶点着色器中（Vertex Shader）。</li>
<li>FLocalVertexFactory：提供从局部空间到世界空间的转换；Static Mesh、Cables、Procedual Mesh使用。</li>
<li>FGPUSkinVertexFactory：用于Skeletal Mesh（需要更多的顶点数据）。</li>
<li>FLandscapeVertexFactory：Landscape是基于VTF（Vertex Texture Fetch），使用高度图来修改顶点位置实现的，所以需要额外的处理。</li>
<li>FParticleVertexFactoryBase：粒子系统使用。</li>
</ul>
<h4 id="FPrimitiveSceneProxy"><a href="#FPrimitiveSceneProxy" class="headerlink" title="FPrimitiveSceneProxy"></a>FPrimitiveSceneProxy</h4><ul>
<li>渲染线程版本的UPrimitiveComponent（虽然我也不知道这个东西是个啥），负责维护每个Component在渲染线程上需要的数据。</li>
</ul>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [1].png" alt="Image [1]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [2].png" alt="Image [2]">

<ul>
<li>Unreal存在游戏线程和渲染线程，两者不能直接访问对方线程中的数据（除非使用一些特定的异步宏）。为了解决这个问题，Unreal在游戏线程中使用UPrimitiveComponent，通过重写<code>CreateSceneProxy()</code>函数来创建自己的FPrimitiveProxy类。<ul>
<li>UCableComponent / FCableSceneProxy：在<code>CreateSceneProxy()</code>函数中创建FCableSceneProxy并进行初始化，然后在<code>SendRenderDynamicData_Concurrent()</code>中将数据发送到渲染线程并借由<code>SetDynamicData_RenderThread()</code>进行数据构造。</li>
<li>UImagePlateFrustrumComponent / FImagePlateFrustrumSceneProxy：由于是用于渲染2D材质，不需要VertexFactory。它仅使用渲染线程的回调函数来计算一些数据画线。FImagePlateFrustumSceneProxy只是在GetDynamicMeshElements时返回演算的结果。</li>
</ul>
</li>
</ul>
<h3 id="Binding-C-to-HLSL"><a href="#Binding-C-to-HLSL" class="headerlink" title="Binding C++ to HLSL"></a>Binding C++ to HLSL</h3><ul>
<li><p>C++宏</p>
<ul>
<li><p><code>IMPLEMENT_MATERIAL_SHADER_TYPE(TemplatePrefix, ShaderClass, SourceFilename, FunctionName, Frequency)</code></p>
<ul>
<li><p>例如：<code>IMPLEMENT_MATERIAL_SHADER_TYPE(,FDepthOnlyPS,TEXT(&quot;/Engine/Private/DepthOnlyPixelShader.usf&quot;),TEXT(&quot;Main&quot;),SF_Pixel)</code></p>
<ul>
<li>这个宏将FDepthOnlyPS绑定到DepthOnlyPixelShader.<strong>usf</strong>中，Main是shader端的入口函数。</li>
<li>Unreal使用“Frequency”来区分shader的类型：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EShaderFrequency</span> &#123;</span>   </span><br><span class="line">	SF_Vertex       	= <span class="number">0</span>,    </span><br><span class="line">	SF_Hull           	= <span class="number">1</span>,    </span><br><span class="line">	SF_Domain        	= <span class="number">2</span>,    </span><br><span class="line">	SF_Pixel         	= <span class="number">3</span>,    </span><br><span class="line">	SF_Geometry      	= <span class="number">4</span>,    </span><br><span class="line">	SF_Compute       	= <span class="number">5</span>,    </span><br><span class="line">	SF_NumFrequencies 	= <span class="number">6</span>,    </span><br><span class="line">	SF_NumBits        	= <span class="number">3</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数“TemplatePrefix”用于模板类与shader的绑定。有些情况下，宏指定一个模板类，然后使用另一个宏实例化来创建特定的实现。（例如为每个可能的lighting type创建变体）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>IMPLEMENT_VERTEX_FACTORY_TYPE(FactoryClass, ShaderFilename, bUsedWithmaterials, bSupportsStaticLighting, bSupportsDynamicLighting, bPrecisePrevWorldPos, bSupportsPositionOnly)</code></p>
<ul>
<li>将C++形式的VertexFactory绑定到一个具体的HLSL文件（Shader）中。</li>
<li>例如：<code>IMPLEMENT_VERTEX_FACTORY_TYPE(FLocalVertexFactory,”/Engine/Private/LocalVertexFactory.ush”,true,true,true,true,true);</code><ul>
<li>这个宏将FLocalVertexFactory与LocalVertexFactory.<strong>ush</strong>进行关联。</li>
<li>因为MeshShader有许多实例，每一个实例会根据自己的光照类型、数据类型进行不同的绑定。shader与FVertexFactory不是一一对应的关系，使用相同渲染路径的类会在这里共用shader。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part3-Drawing-Policies"><a href="#Part3-Drawing-Policies" class="headerlink" title="Part3 Drawing Policies"></a>Part3 Drawing Policies</h2><h3 id="Drawing-Policies"><a href="#Drawing-Policies" class="headerlink" title="Drawing Policies"></a>Drawing Policies</h3><ul>
<li>并不是继承于一个基类。决定哪个shader变体用于绘制物体。</li>
</ul>
<h4 id="FDepthDrawingPolicy"><a href="#FDepthDrawingPolicy" class="headerlink" title="FDepthDrawingPolicy"></a>FDepthDrawingPolicy</h4><ul>
<li>获取Material的shader<ul>
<li><code>VertexShader = InMaterialResource.GetShader&lt;TDepthOnlyVS&lt;false&gt; &gt;(VertexFactory-&gt;GetType());</code></li>
<li><code>PixelShader = InMaterialResource.GetShader&lt;FDepthOnlyPS&gt;(InVertexFactory-&gt;GetType());</code></li>
<li>如果是用于tessellation（曲面细分）则还需要Hull Shader和Domain Shader（？）</li>
</ul>
</li>
<li>使用<code>SetSharedState()</code>和<code>SetMeshRenderState()</code>来传递参数</li>
</ul>
<h4 id="FBasePassDrawingPolicy"><a href="#FBasePassDrawingPolicy" class="headerlink" title="FBasePassDrawingPolicy"></a>FBasePassDrawingPolicy</h4><ul>
<li><p>继承模板类：<code>template&lt;typenameLightMapPolicyType&gt; classTBasePassDrawingPolicy : public FBasePassDrawingPolicy</code></p>
<ul>
<li>通过识别不同的光照类型来获取不同的shader。</li>
</ul>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [3].png" alt="Image [3]">

<ul>
<li><code>template &lt;ELightMapPolicyType Policy&gt; void GetUniformBasePassShaders (...)</code> <ul>
<li>使用这个函数获得对应光照的shader。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Drawing-Policy-Factory"><a href="#Drawing-Policy-Factory" class="headerlink" title="Drawing Policy Factory"></a>Drawing Policy Factory</h3><ul>
<li>检查材质或者VertexFactory的状态，然后创建正确的Drawing Policy。</li>
</ul>
<h4 id="FdepthDrawingPolicyFactory"><a href="#FdepthDrawingPolicyFactory" class="headerlink" title="FdepthDrawingPolicyFactory"></a>FdepthDrawingPolicyFactory</h4><ul>
<li><p><code>void FDepthDrawingPolicyFactory::AddStaticMesh(FScene* Scene, FStaticMesh* StaticMesh)</code></p>
<ul>
<li>获取static mesh，根据属性和设置确定对应的Drawing Policy（在这里有FDepthDrawingPolicy和FPositionOnlyDepthDrawingPolicy），然后将其加入到FScene的列表中。</li>
</ul>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [4].png" alt="Image [4]"></li>
<li><p><code>bool FDepthDrawingPolicyFactory::DrawMesh(...)</code> / <code>bool FDepthDrawingPolicyFactory::DrawDynamicMesh(...)</code> / <code>boolFDepthDrawingPolicyFactory::DrawStaticMesh(...)</code></p>
<ul>
<li>被调用用于进行渲染。</li>
</ul>
</li>
<li><p>也可以绘制mesh batch。但mesh batch不会被加入到列表中，而是通过RHI layer建立GPU状态，并带哦用其他的drawing policy来绘制mesh。</p>
</li>
</ul>
<h2 id="Part4-The-Deferred-Shading-Pipeline"><a href="#Part4-The-Deferred-Shading-Pipeline" class="headerlink" title="Part4 The Deferred Shading Pipeline"></a>Part4 The Deferred Shading Pipeline</h2><p>相比前向渲染，可以支持多光源，复杂度为n+m。n场景物体数量，m场景光源数量。</p>
<h3 id="Vertex-Factories"><a href="#Vertex-Factories" class="headerlink" title="Vertex Factories"></a>Vertex Factories</h3><h4 id="Changing-Input-Data"><a href="#Changing-Input-Data" class="headerlink" title="Changing Input Data"></a>Changing Input Data</h4><ul>
<li>CPU：顶点数据保存在FVertexFactory中；GPU：FVertexFactoryInput — 来自C++端的数据输入，在不同的Shader头文件中会有不同的定义，使用方式也不同。</li>
<li>存在通用的函数被定义来处理输入数据：GetVertexFactoryIntermediates, VertexFactoryGetWorldPosition, GetMaterialVertexParameters。</li>
</ul>
<h4 id="Changing-Output-Data"><a href="#Changing-Output-Data" class="headerlink" title="Changing Output Data"></a>Changing Output Data</h4><ul>
<li><p>FBasePassVSOutput：可以根据是否使用Tessellation将其定义为FBasePassVSToDS或FBasePassVSToPS。（曲面细分会需要在VS和PS之间引入Hull Shader和Domain Shader两个过程）</p>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [5].png" alt="Image [5]">

<ul>
<li>这里我们可以看到FVertexFactoryInterpolants<em>和FBasePassInterpolants</em>，这些定义的数据保存了顶点插值相关的内容。</li>
</ul>
</li>
</ul>
<h3 id="Base-Pass-Pixel-Shader"><a href="#Base-Pass-Pixel-Shader" class="headerlink" title="Base Pass Pixel Shader"></a>Base Pass Pixel Shader</h3><h4 id="Material-Graph-to-HLSL"><a href="#Material-Graph-to-HLSL" class="headerlink" title="Material Graph to HLSL"></a>Material Graph to HLSL</h4><ul>
<li><strong>MaterialTemplates.ush</strong><ul>
<li>%s =&gt; string format。由引擎将材质编辑器中的节点填充到这里。结构体、函数中都会存在。结构体中存放材质编辑器中需要的数据，函数用于计算（调用在材质编辑器中使用到的节点）。</li>
</ul>
</li>
</ul>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [6].png" alt="Image [6]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [7].png" alt="Image [7]">

<h4 id="The-“Primitive”-Variable"><a href="#The-“Primitive”-Variable" class="headerlink" title="The “Primitive” Variable"></a>The “Primitive” Variable</h4><img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [8].png" alt="Image [8]">

<p>​        在C++端用宏声明。在每个图元（primitive）在GPU上被绘制前，这些宏会定义一个由渲染器设置的结构体。</p>
<h4 id="Creating-the-GBuffer"><a href="#Creating-the-GBuffer" class="headerlink" title="Creating the GBuffer"></a>Creating the GBuffer</h4><ul>
<li><p>GBuffer（几何缓冲区）：存储关于几何的不同信息，如world normal、base color、roughness…在计算照时，Unreal会采样这些缓冲来计算最终的shading。在这之前，Unreal会通过几个步骤创建并填充GBuffer。</p>
</li>
<li><p>GBuffer的内容时根据项目设置变化的。通常的情况是5纹理Gbuffer（5 texture GBuffer）（后缀A-E）:</p>
<ul>
<li>GBufferA.rgb = World Normal, GbufferA.a = PerObjectGBufferData;</li>
<li>GBufferB.rgba = Metallic, Specular, Roughness, ShadingModelID;</li>
<li>GBufferC.rgb = BaseColor, GBufferC.a = GBufferAO;</li>
<li>GBufferD = custom data;</li>
<li>GBufferE = precomputed shadow factors。</li>
</ul>
</li>
<li><p>在入口函数FPixelShaderInOut_MainPS中，先调用MaterialTemplate.ush中声明的函数来完成获取BaseColor、Metallic、Specular、AO、Roughness等值；如果使用了次表面散射，则会继续获取数据计算此表面散射的颜色，否则默认值会被设置为0；接着如果项目中启用了DBuffer，Unreal会允许DBuffer Decals（贴花）来修改GBuffer中的结果；这之后，Unreal会计算Opacity，并进行体积光照贴图的计算；最后创建FGBufferData结构，并将数据打包其中，每个FGBufferData实例代表一个像素。</p>
</li>
</ul>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [9].png" alt="Image [9]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [10].png" alt="Image [10]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [11].png" alt="Image [11]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [12].png" alt="Image [12]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [13].png" alt="Image [13]">

<h4 id="Setting-the-GBuffer-Shading-Model"><a href="#Setting-the-GBuffer-Shading-Model" class="headerlink" title="Setting the GBuffer Shading Model"></a>Setting the GBuffer Shading Model</h4><ul>
<li><code>SetGBufferShadingModel(...)</code><ul>
<li>函数声明在ShadingModelsMaterial.ush中。</li>
<li>获取GBuffer的数据，并将其按照shading model的需要重新分配。<ul>
<li>大部分模型只是简单地分配模型数据，而不进行修改；</li>
<li>某些模型（次表面散射等）将自定义数据通道附加到GBuffer中。</li>
</ul>
</li>
<li>将ShadingModelID写入GBuffer — 每像素存储的整数值，允许延迟传递查找每个像素稍后应当使用的shading model。</li>
<li>如果需要使用GBuffer的CustomData通道，则需要修改BasePassCommon.ush中的WRITES_CUSTOMDATA_TO_GBUFFER，如果未在此处添加shading model，自定义数据会被丢弃。<ul>
<li><code>#define **WRITES_CUSTOMDATA_TO_GBUFFER** (USES_GBUFFER &amp;&amp; (MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN || MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE || MATERIAL_SHADINGMODEL_CLEAR_COAT || MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE || MATERIAL_SHADINGMODEL_HAIR || MATERIAL_SHADINGMODEL_CLOTH || MATERIAL_SHADINGMODEL_EYE))</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Using-the-Data"><a href="#Using-the-Data" class="headerlink" title="Using the Data"></a>Using the Data</h4><ul>
<li><code>EncodeGBuffer()</code></li>
</ul>
<h3 id="Deferred-Light-Pixel-Shader"><a href="#Deferred-Light-Pixel-Shader" class="headerlink" title="Deferred Light Pixel Shader"></a>Deferred Light Pixel Shader</h3><ul>
<li>DeferredLightPixelShaders.usf 计算光对像素影响的地方。</li>
<li>Non shadow-casting lights — indirect lighting — shadow casting lights</li>
<li>Unreal使用类似的Shader来处理Shadow casting lights 和 non shadow-casting lights，唯一不同的是预处理阶段，Unreal会计算一张ScreenShadowMaskTexture，它是场景中阴影像素的屏幕空间表示。<ul>
<li>为了计算这个，Unreal会渲染几何图形。这并不是重新渲染物体，而是对GBuffer进行采样，结合给定像素的深度，来查看它是否会出现投射光影。</li>
</ul>
</li>
</ul>
<h2 id="Part6-Adding-a-New-Shading-Model"><a href="#Part6-Adding-a-New-Shading-Model" class="headerlink" title="Part6 Adding a New Shading Model"></a>Part6 Adding a New Shading Model</h2><p>1、在EngineType.h中找到<code>EMaterialShadingModel</code>，在其中添加MSM_xxxx（在MSM_MAX前）— 这个会反映在材质编辑器的shading model下拉菜单里。</p>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [14].png" alt="Image [14]">

<p>2、给材质编辑器添加引脚：在Material.cpp中找到<code>UMaterial :: IsPropertyActive(...)</code>，给switch中添加判断使用自定义的shading model的语句。（这个步骤仅仅只是修改了UI，需要确保着色器使用提供给这些引脚的数据）</p>
<ul>
<li>修改引脚名字则可以在MaterialGraph.cpp中寻找对应的函数（命名为<code>GetxxxPinName(...)</code>），在其中加入判断shadingmodel以及对应名称的语句。对于Specular、Roughness等没有定义函数的，可以自己添加函数，并在文件开头处调用。</li>
</ul>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [15].png" alt="Image [15]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [16].png" alt="Image [16]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [17].png" alt="Image [17]">

<p>3、修改HLSL预处理器定义：MaterialShared.cpp：<code>FMaterial::SetupMaterialEnvironment(...)</code>，修改OutEnvironment变量。在GetShadingModel的switch语句中添加MSM_xxxx的case。（4.25版本在HLSLMaterialTranslator.cpp的<code>void FHLSLMaterialTranslator::GetMaterialEnvironment(...)</code>中）</p>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [18].png" alt="Image [18]">

<p>(以上c++部分修改完成，可以重新编译，但不要打开编辑器)</p>
<p>4、更新GBuffer的ShadingModelID</p>
<ul>
<li>在shader中定义关键字：DeferredShadingCommon.ush中添加关键字。并在<code>GetShadingModelColor(...)</code>中定义着色器颜色。</li>
</ul>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [19].png" alt="Image [19]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [20].png" alt="Image [20]">

<p>(以下基于Deferred Shading)</p>
<ul>
<li>开启CustomData写入的关键字（如果你之前有添加customdata的引脚）：在BasePassCommon.ush中为关键字WRITES_CUSTOMDATA_TO_GBUFFER增加一个条件。然后在ShadingModelMaterial.ush的<code>SetGBufferForShadingModel(...)</code>中添加预处理判断，在使用自定义的shadingmodel时，将CustomData 0 写入到GBuffer.CustomData.x中。</li>
</ul>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [21].png" alt="Image [21]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [22].png" alt="Image [22]">

<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [23].png" alt="Image [23]">

<p>（以下基于Mobile Shading）</p>
<p>5、打开MobileBasePassPixelShader.usf，大部分的操作都在这个地方完成。</p>
<ul>
<li><p>做卡渲需要做个ramp，如果在材质编辑器里只获取光照计算NdotL来采样Ramp贴图的话，无法将自阴影算进去。但mobile管线下，材质编辑器无法获取阴影的信息，因此我们只能想办法将自定义贴图采样这个步骤移到内部完成。</p>
<ul>
<li><p>方法1：在MaterialTemplate.ush中添加相关的模板函数，并在C++中完成自动生成HLSL的工作，相关链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/136680585">Unreal向shader传入材质贴图 - 知乎 (zhihu.com)</a>。（这位大佬还有一篇给自定义shadingmodel增加自定义引脚的文章，感觉未来可能也会用到，上面这篇文章里有附链接）</p>
</li>
<li><p>方法2：编译一次Shader，查看编译的HLSL文件，HLSL中会有采样贴图的步骤，寻找与需要的贴图相关的采样代码，复制到basepasspixelshader中使用。</p>
<p>例如：这里我想使用连在EmissiveColor上的贴图，那么我就在HLSL中找到给EmissiveColor赋值的代码行（因为通常我们在basepixelshader中使用的都是GetMaterialxxxx，而这个函数的实现就在MaterialTemplate.ush中，非常简单一般就是把PixelMaterialInputs.xxx给返回了，因此这里我们只要寻找PixelMaterialInputs.xxx就行）；</p>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [24].png" alt="Image [24]">

<p>然后我们发现EmissiveColor = Local1，我们往前寻找Local1的定义；</p>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [25].png" alt="Image [25]">

<p>这里我们看到Local1来自Local0 + 另外一个东西（暂时不知道是干什么的，输出看了一下是个黑色的东西），而Local0就是在采样贴图，因此我们把采样贴图的这个函数Texure2DSampleBias连同底层给这张贴图赋予的ID（即Material.Texture2D_0）一起复制到basspasspixelshader中使用就行。（我这里是为了用shadow*NoL来采样Ramp贴图。）</p>
</li>
</ul>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [26].png" alt="Image [26]"></li>
</ul>
<p>6、由于需要在材质编辑器中获得光照信息，但UE4 mobile端材质编辑器屏蔽使用灯光信息，无法获取光源的方向，颜色等数据。Mobile Lighting的信息是运行时生成的UniformBuffer，在MaterialTemplate.ush里包含**”/Engine/Generated/UniformBuffers/MobileDirectionalLight.ush”**可以解决Custom Expression对灯光声明引用的问题。（在custom节点里获取）</p>
<img src="/2021/08/22/UE4%20Rendering%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/Image [27].png" alt="Image [27]">

<p>7、切换到移动端rendering level，像是上面获取光照方向的方法只能在Mobile shading中使用。在settings-&gt;Preview rendering level中切换。<strong>（注意创建工程时选移动平台）</strong></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/UE4/" rel="tag"># UE4</a>
              <a href="/tags/ShadingModel/" rel="tag"># ShadingModel</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/22/AboutMe/" rel="prev" title="Welcome to my blog!">
                  <i class="fa fa-chevron-left"></i> Welcome to my blog!
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/22/UE4%20%E9%A3%8E%E6%A0%BC%E5%8C%96%E8%8D%89%E5%9C%B0%E4%BA%A4%E4%BA%92/" rel="next" title="UE4风格化草地制作与基于PivotPainter的草地交互">
                  UE4风格化草地制作与基于PivotPainter的草地交互 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Yuren</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
